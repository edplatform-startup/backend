/**
 * LaTeX Validation and Repair Utilities
 * 
 * Handles common LaTeX issues in LLM-generated content:
 * - Delimiter conversion: $...$ → \(...\), $$...$$ → \[...\]
 * - Bracket balancing: x^2 → x^{2}
 * - Non-standard commands: \rect → \mathrm{rect}
 * - Greek symbol spacing issues
 */

/**
 * Non-standard LaTeX commands commonly generated by LLMs
 * Maps to their standard equivalents
 */
const NON_STANDARD_COMMANDS = {
    '\\rect': '\\mathrm{rect}',
    '\\tri': '\\mathrm{tri}',
    '\\sha': '\\mathrm{sha}',
    '\\sinc': '\\mathrm{sinc}',
    '\\sgn': '\\mathrm{sgn}',
    '\\step': '\\mathrm{step}',
    '\\comb': '\\mathrm{comb}',
    '\\dirac': '\\delta',
};

/**
 * Greek letters that need proper LaTeX commands
 */
const GREEK_LETTERS = [
    'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta',
    'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho',
    'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega',
    'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta',
    'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho',
    'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega'
];

/**
 * Normalizes LaTeX delimiters from $...$ format to \(...\) format.
 * - Single $ → \( ... \) for inline math
 * - Double $$ → \[ ... \] for display math
 * 
 * @param {string} text - Input text containing LaTeX
 * @returns {string} - Text with normalized delimiters
 */
export function normalizeLatexDelimiters(text) {
    if (!text || typeof text !== 'string') return text || '';

    let result = text;

    // First, handle display math $$...$$ → \[...\]
    // Must do this before inline to avoid partial matches
    result = result.replace(/\$\$([^$]+)\$\$/g, '\\[$1\\]');

    // Then handle inline math $...$ → \(...\)
    // Use negative lookbehind/ahead to avoid matching escaped \$ or already converted
    // Also avoid matching $$ (which would be display math remnants)
    result = result.replace(/(?<!\$)\$(?!\$)([^$\n]+?)\$(?!\$)/g, '\\($1\\)');

    return result;
}

/**
 * Fixes common bracket and brace issues in LaTeX
 * - Single char superscripts: x^2 → x^{2}
 * - Single char subscripts: x_i → x_{i}
 * - Already braced content is left alone
 * 
 * @param {string} text - Input LaTeX text
 * @returns {string} - Text with fixed brackets
 */
export function fixBracketBalance(text) {
    if (!text || typeof text !== 'string') return text || '';

    let result = text;

    // Fix superscripts: x^2 → x^{2}, but not x^{...} or x^\ (command)
    // Match ^ followed by a single alphanumeric that's NOT followed by more alphanumerics or {
    result = result.replace(/\^([a-zA-Z0-9])(?![a-zA-Z0-9{])/g, '^{$1}');

    // Fix subscripts: x_i → x_{i}, but not x_{...} or x_\ (command)
    result = result.replace(/_([a-zA-Z0-9])(?![a-zA-Z0-9{])/g, '_{$1}');

    return result;
}

/**
 * Replaces non-standard LaTeX commands with their standard equivalents.
 * 
 * @param {string} text - Input LaTeX text
 * @returns {string} - Text with standard commands
 */
export function replaceNonStandardCommands(text) {
    if (!text || typeof text !== 'string') return text || '';

    let result = text;

    for (const [nonStandard, standard] of Object.entries(NON_STANDARD_COMMANDS)) {
        // Match the command followed by a non-letter (to avoid partial matches)
        // e.g., \rect should match but \rectangle should not
        const regex = new RegExp(
            nonStandard.replace(/\\/g, '\\\\') + '(?![a-zA-Z])',
            'g'
        );
        result = result.replace(regex, standard);
    }

    return result;
}

/**
 * Ensures Greek letters in math mode have proper LaTeX commands.
 * Fixes cases where LLM outputs "omega" instead of "\omega".
 * Only applies within math delimiters.
 * 
 * @param {string} text - Input text
 * @returns {string} - Text with proper Greek letter commands
 */
export function fixGreekLetters(text) {
    if (!text || typeof text !== 'string') return text || '';

    let result = text;

    // Process inline math \(...\)
    result = result.replace(/\\\(([^)]+)\\\)/g, (match, mathContent) => {
        let fixed = mathContent;
        for (const letter of GREEK_LETTERS) {
            // Match the letter as a standalone word (not part of another word, not already a command)
            const regex = new RegExp(`(?<!\\\\)\\b${letter}\\b`, 'g');
            fixed = fixed.replace(regex, `\\${letter}`);
        }
        return `\\(${fixed}\\)`;
    });

    // Process display math \[...\]
    result = result.replace(/\\\[([^\]]+)\\\]/g, (match, mathContent) => {
        let fixed = mathContent;
        for (const letter of GREEK_LETTERS) {
            const regex = new RegExp(`(?<!\\\\)\\b${letter}\\b`, 'g');
            fixed = fixed.replace(regex, `\\${letter}`);
        }
        return `\\[${fixed}\\]`;
    });

    return result;
}

/**
 * Validates and repairs LaTeX content.
 * Applies all fixes in the correct order.
 * 
 * @param {string} text - Input text containing LaTeX
 * @returns {string} - Repaired text
 */
export function validateAndRepairLatex(text) {
    if (!text || typeof text !== 'string') return text || '';

    let result = text;

    // 1. First normalize delimiters ($→\( )
    result = normalizeLatexDelimiters(result);

    // 2. Replace non-standard commands
    result = replaceNonStandardCommands(result);

    // 3. Fix bracket balance (superscripts/subscripts)
    result = fixBracketBalance(result);

    // 4. Fix Greek letters in math mode
    result = fixGreekLetters(result);

    return result;
}

/**
 * Applies LaTeX validation/repair to all text fields in a quiz question.
 * 
 * @param {object} question - Quiz question object
 * @returns {object} - Question with repaired LaTeX
 */
export function repairQuizQuestion(question) {
    if (!question || typeof question !== 'object') return question;

    const repaired = { ...question };

    if (typeof repaired.question === 'string') {
        repaired.question = validateAndRepairLatex(repaired.question);
    }

    if (Array.isArray(repaired.options)) {
        repaired.options = repaired.options.map(opt =>
            typeof opt === 'string' ? validateAndRepairLatex(opt) : opt
        );
    }

    if (Array.isArray(repaired.explanation)) {
        repaired.explanation = repaired.explanation.map(exp =>
            typeof exp === 'string' ? validateAndRepairLatex(exp) : exp
        );
    }

    return repaired;
}

/**
 * Applies LaTeX validation/repair to a flashcard.
 * 
 * @param {object} card - Flashcard object with front/back
 * @returns {object} - Flashcard with repaired LaTeX
 */
export function repairFlashcard(card) {
    if (!card || typeof card !== 'object') return card;

    const repaired = { ...card };

    if (typeof repaired.front === 'string') {
        repaired.front = validateAndRepairLatex(repaired.front);
    }

    if (typeof repaired.back === 'string') {
        repaired.back = validateAndRepairLatex(repaired.back);
    }

    return repaired;
}

/**
 * Applies LaTeX validation/repair to a practice problem.
 * 
 * @param {object} problem - Practice problem object
 * @returns {object} - Problem with repaired LaTeX
 */
export function repairPracticeProblem(problem) {
    if (!problem || typeof problem !== 'object') return problem;

    const repaired = { ...problem };

    if (typeof repaired.question === 'string') {
        repaired.question = validateAndRepairLatex(repaired.question);
    }

    if (repaired.sample_answer && typeof repaired.sample_answer === 'object') {
        if (typeof repaired.sample_answer.final_answer === 'string') {
            repaired.sample_answer = {
                ...repaired.sample_answer,
                final_answer: validateAndRepairLatex(repaired.sample_answer.final_answer)
            };
        }
        if (Array.isArray(repaired.sample_answer.solution_steps)) {
            repaired.sample_answer = {
                ...repaired.sample_answer,
                solution_steps: repaired.sample_answer.solution_steps.map(step =>
                    typeof step === 'string' ? validateAndRepairLatex(step) : step
                )
            };
        }
    }

    return repaired;
}
