import { v4 as uuidv4 } from 'uuid';
import stringSimilarity from 'string-similarity';
import { callStageLLM as defaultLLMCaller } from './llmCall.js';

let llmCaller = defaultLLMCaller;

export function __setLLMCaller(fn) {
  llmCaller = fn;
}

export function __resetLLMCaller() {
  llmCaller = defaultLLMCaller;
}
import { STAGES } from './modelRouter.js';
import { tryParseJson } from '../utils/jsonUtils.js';

/**
 * @typedef {Object} ContentPlans
 * @property {string} [reading] - Prompt for reading generation
 * @property {string[]} [video] - Search queries for video
 * @property {string} [quiz] - Prompt for quiz generation
 * @property {string} [flashcards] - Prompt for flashcard generation
 * @property {string} [practice_exam] - Prompt for practice exam generation
 */

/**
 * @typedef {Object} LessonNode
 * @property {string} slug_id
 * @property {string} title
 * @property {string} module_group
 * @property {number} estimated_minutes
 * @property {"Remember" | "Understand" | "Apply" | "Analyze" | "Evaluate"} bloom_level
 * @property {number} intrinsic_exam_value
 * @property {string} architectural_reasoning
 * @property {ContentPlans} content_plans
 * @property {string[]} dependencies
 * @property {string[]} [original_source_ids]
 */

/**
 * @typedef {Object} LessonGraph
 * @property {LessonNode[]} lessons
 */

/**
 * Generates a DAG of atomic lessons from a rough course draft.
 * @param {Object} grokDraftJson - The rough draft JSON from Grok.
 * @param {Object} userConfidenceMap - Map of slug_id -> confidence_score (0-1).
 * @returns {Promise<{ finalNodes: any[], finalEdges: any[] }>}
 */
export async function generateLessonGraph(grokDraftJson, userConfidenceMap = {}, userId, mode = 'deep') {

  // Step 1: The Architect Call
  const systemPrompt = `You are the Lesson Architect. Your goal is to transform a rough course outline into a high-quality Directed Acyclic Graph (DAG) of Atomic Lessons.

INPUT: A rough course draft (JSON) generated by a junior process.
OUTPUT: A structured JSON object containing a list of lessons with dependencies.

CRITICAL RULES:
1. **Granularity:** "Atomic" means a lesson that takes 15-45 minutes to complete. Split broad topics. Merge tiny fragments (unless foundational).
2. **Lineage:** You MUST track the 'original_source_ids' from the input. If you merge topics, list ALL their IDs. This preserves user data.
3. **No Cycles:** The graph must be strictly Acyclic.
4. **Module Organization:** Aim for modules with MORE than 2 lessons whenever possible to keep content properly chunked and modularized. Single-lesson or two-lesson modules should only be used when the topic is genuinely standalone or foundational. Well-organized modules (3-6 lessons) improve learning flow and coherence.
5. **Content Type Diversity:** You may include MULTIPLE instances of each content type per lesson if appropriate for learning:
   - A lesson can have multiple readings (e.g., theory + examples + edge cases)
   - A lesson can have multiple videos (e.g., intro + deep dive + worked examples)
   - A lesson can have multiple quizzes (e.g., conceptual check + application problems)
  - A lesson can include practice exams or longer free-response drills to mirror midterm/final formats
   - ALL content should flow in a logical learning order for maximum comprehension
   - A lesson can include practice exams or longer free-response drills to mirror midterm/final formats
   - ALL content should flow in a logical learning order for maximum comprehension
6. **Lesson-End Quizzes:** IMPORTANT: Always include a quiz as the LAST content type in each lesson. This quiz should assess understanding of the material covered in THAT lesson (and prior lessons if needed). Do not include questions on topics that haven't been taught yet. For the final lesson of a module, the quiz can be cumulative for that module.
7. **Specific Generation Plans:** For each content type you include, provide detailed, specific prompts:
   - **reading:** ${mode === 'cram' ? 'Concise, high-yield focus. Emphasize exam-critical concepts and key definitions.' : 'Highly detailed prompt for a writer (e.g., "Use a gear analogy," "Focus on formal proofs"). Focus on intuitive understanding and exact topics.'} **Mermaid Diagrams:** If a visual aid is helpful, explicitly request a specific Mermaid diagram type (e.g., "Include a sequence diagram for the handshake protocol" or "Use a class diagram to show the inheritance hierarchy"). Supported types: sequenceDiagram, classDiagram, stateDiagram-v2, erDiagram, gantt, journey, pie, mindmap, quadrantChart.
   - **video:** ${mode === 'cram' ? 'Only include if the concept is exceptionally difficult or visual. 1-2 high-yield search queries.' : '2-3 general, high-level YouTube search queries for broad concepts (e.g., "Introduction to Photosynthesis" rather than "Calvin Cycle Step 3"). IMPORTANT: Only include video plans if the concept is exceptionally difficult, the user is weak on it, or a visual demonstration is absolutely necessary. Otherwise, omit.'}
   - **quiz:** Detailed prompt for an examiner. Explicitly enumerate the main topics/subsections of the lesson and ensure the quiz has at least one question per major topic. Request varying difficulty levels (Easy, Medium, Hard) and ensure at least one "Challenge Question" that integrates multiple concepts to test deep understanding. **CRITICAL:** Ensure quiz topics align strictly with the reading and prerequisites.
   - **flashcards:** Prompt focusing on what to memorize (definitions vs. procedural steps).
  - **practice_exam:** Prompt describing the desired number of free-response problems, rubric expectations, and authentic exam traps to include.
8. **IDs:** Use "Semantic Slugs" (kebab-case) for IDs.
9. **Reasoning:** The 'architectural_reasoning' field must explain your grouping logic, why you assigned the specific exam value (1-10), and why you chose the specific content mix.
10. **Naming:** NEVER number modules or lessons in the title or module_group (e.g., 'Limits', not 'Week 1: Limits').
11. **MODE: ${mode.toUpperCase()}**:
    ${mode === 'cram' ? '- Structure for speed. Group topics aggressively. Fewer lessons. Focus on high-yield material.' : '- Granular lessons. Detailed breakdown. Ensure comprehensive coverage.'}

Output STRICT VALID JSON format (no markdown, no comments):
{
  "lessons": [
    {
      "slug_id": "chain-rule-application",
      "title": "Mastering the Chain Rule",
      "module_group": "Limits",
      "estimated_minutes": 30,
      "bloom_level": "Apply",
      "intrinsic_exam_value": 8,
      "architectural_reasoning": "Merged st1_1 and st1_2 to create a cohesive 30-min lesson. Rated 8/10 because the syllabus highlights this for the midterm.",
      "dependencies": ["limits-intro"],
      "original_source_ids": ["st1_1", "st1_2"],
      
      "content_plans": {
         "reading": "Explain the chain rule using a 'peeling the onion' analogy. Focus on identifying inner vs outer functions.",
         "video": ["chain rule calculus intuition", "chain rule visualization 3blue1brown"],
         "quiz": "Generate 3-5 multiple-choice questions. Question 1 on Chain Rule intuition, Question 2 on identifying inner/outer functions, Question 3 on applying the formula. Include a Challenge Question involving a trigonometric function inside a polynomial.",
         "flashcards": "Focus on the formula f'(g(x))g'(x) and recognizing composite functions."
      }
    }
  ]
}`;

  const userPrompt = `Rough Draft: ${JSON.stringify(grokDraftJson)}`;

  const { result } = await llmCaller({
    stage: STAGES.LESSON_ARCHITECT,
    maxTokens: 20000,
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ],
    responseFormat: { type: 'json_object' },
    requestTimeoutMs: 1800000, // 30 minutes for long-running course generation
    allowWeb: true,
    maxToolIterations: 16,
    userId,
  });

  let lessonGraph;
  try {
    const cleanJson = result.content
      .replace(/^```json\s*/, '')
      .replace(/^```\s*/, '')
      .replace(/\s*```$/, '')
      .replace(/\\'/g, "'");

    lessonGraph = tryParseJson(cleanJson, 'LessonArchitect');
  } catch (e) {
    throw new Error('Invalid JSON response from Lesson Architect');
  }

  if (!lessonGraph || !Array.isArray(lessonGraph.lessons)) {
    throw new Error('Invalid response structure: missing lessons array');
  }


  // Step 2: Self-Healing Validation Logic
  const validSlugs = new Set(lessonGraph.lessons.map((l) => l.slug_id));
  const brokenDependenciesMap = new Map(); // lesson_slug -> [bad_deps]

  // Stage 1: Fuzzy Repair & Identification
  for (const lesson of lessonGraph.lessons) {
    const newDependencies = [];
    const badDepsForLesson = [];

    for (const dep of lesson.dependencies || []) {
      if (validSlugs.has(dep)) {
        newDependencies.push(dep);
      } else {
        const matches = stringSimilarity.findBestMatch(dep, Array.from(validSlugs));
        if (matches.bestMatch.rating > 0.9) {
          newDependencies.push(matches.bestMatch.target);
        } else {
          // Keep it for Stage 2, but track it as broken
          newDependencies.push(dep);
          badDepsForLesson.push(dep);
        }
      }
    }
    lesson.dependencies = newDependencies;
    if (badDepsForLesson.length > 0) {
      brokenDependenciesMap.set(lesson.slug_id, badDepsForLesson);
    }
  }

  // Stage 2: Targeted Regeneration
  if (brokenDependenciesMap.size > 0) {

    const allBadSlugs = new Set();
    for (const deps of brokenDependenciesMap.values()) {
      deps.forEach(d => allBadSlugs.add(d));
    }

    const repairPrompt = `You generated these nodes: ${JSON.stringify(Array.from(validSlugs))}.
You referenced these non-existent dependencies: ${JSON.stringify(Array.from(allBadSlugs))}.
Return a JSON map correcting the Bad Slugs to existing ones, or map to null to remove.
Example: { "bad-slug": "good-slug", "another-bad": null }`;

    try {
      const { result: repairResult } = await llmCaller({
        stage: STAGES.LESSON_ARCHITECT, // Re-use same stage/model
        maxTokens: 8000,
        messages: [{ role: 'user', content: repairPrompt }],
        responseFormat: { type: 'json_object' },
        requestTimeoutMs: 1800000, // 30 minutes for repair call as well
        userId,
      });

      const corrections = tryParseJson(repairResult.content, 'LessonArchitect Repair');

      // Apply corrections
      for (const [slug, badDeps] of brokenDependenciesMap.entries()) {
        const lesson = lessonGraph.lessons.find(l => l.slug_id === slug);
        if (!lesson) continue;

        const finalDeps = [];
        for (const dep of lesson.dependencies) {
          if (badDeps.includes(dep)) {
            const correction = corrections[dep];
            if (correction && validSlugs.has(correction)) {
              finalDeps.push(correction);
            } else {
              // Stage 3: Orphan Fallback
            }
          } else {
            finalDeps.push(dep);
          }
        }
        lesson.dependencies = [...new Set(finalDeps)]; // Dedupe
      }

    } catch (e) {
      // Fallback to dropping all bad deps (Stage 3) implicitly since we didn't add them back
    }
  }

  // Step 2.5: Inject Module Quizzes
  // Group lessons by module
  const moduleMap = new Map();
  lessonGraph.lessons.forEach(l => {
    if (!moduleMap.has(l.module_group)) {
      moduleMap.set(l.module_group, []);
    }
    moduleMap.get(l.module_group).push(l);
  });

  // Create Module Quiz for each module
  for (const [moduleName, lessons] of moduleMap.entries()) {
    // Skip if module already has a module quiz (unlikely but safe)
    if (lessons.some(l => l.title === 'Module Quiz')) continue;

    const moduleSlug = moduleName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
    const quizSlug = `module-quiz-${moduleSlug}`;

    // Gather context from lessons in this module
    const lessonSummaries = lessons.map(l => {
      // Use title and reading prompt to give context
      const readingPrompt = l.content_plans?.reading || '';
      // Truncate reading prompt to avoid excessive context, just get the gist
      const gist = readingPrompt.length > 150 ? readingPrompt.substring(0, 150) + '...' : readingPrompt;
      return `- Lesson: "${l.title}" (Focus: ${gist})`;
    }).join('\n');

    const quizPrompt = `Create a comprehensive Module Quiz for the module "${moduleName}".
The quiz should cover the key concepts from the following lessons:
${lessonSummaries}

Requirements:
1. This is a cumulative review quiz for the entire module.
2. Only include questions that are DIFFICULT and SUMMATIVE in nature â€” i.e., questions that require problem-solving, application, analysis, or evaluation rather than simple recall of facts or definitions.
3. Aim for questions that integrate multiple concepts or require reasoning across lessons; include challenge-style problems where appropriate.
4. Include at least 6-7 questions in the quiz.
5. Provide a balanced mix of difficulty levels among those difficult questions where applicable (e.g., several multi-step application problems and at least one integrative challenge).
6. Provide detailed explanations for every answer (correct and incorrect), explaining the reasoning and common misconceptions.
7. Use proper LaTeX formatting for any math.
8. Do NOT include content from outside this module.`;

    const moduleQuizLesson = {
      slug_id: quizSlug,
      title: 'Module Quiz',
      module_group: moduleName,
      estimated_minutes: 20,
      bloom_level: 'Evaluate',
      intrinsic_exam_value: 10,
      architectural_reasoning: 'Automatically generated comprehensive review quiz for the module.',
      dependencies: lessons.map(l => l.slug_id), // Depend on ALL lessons in the module
      original_source_ids: [],
      content_plans: {
        quiz: quizPrompt
      }
    };

    lessonGraph.lessons.push(moduleQuizLesson);
  }

  // Step 3: Normalization & Output
  const slugToUuid = new Map();
  lessonGraph.lessons.forEach(l => slugToUuid.set(l.slug_id, uuidv4()));

  const finalNodes = lessonGraph.lessons.map(l => {
    // Calculate Confidence Score
    let confidenceSum = 0;
    let sourceCount = 0;
    const sources = l.original_source_ids || [];

    if (sources.length > 0) {
      sources.forEach(sid => {
        if (typeof userConfidenceMap[sid] === 'number') {
          confidenceSum += userConfidenceMap[sid];
          sourceCount++;
        }
      });
    }

    // Default to 0.1 if no sources or no matching scores
    const confidenceScore = sourceCount > 0 ? Number((confidenceSum / sourceCount).toFixed(2)) : 0.1;

    return {
      id: slugToUuid.get(l.slug_id),
      title: l.title,
      description: null,
      intrinsic_exam_value: l.intrinsic_exam_value,
      bloom_level: l.bloom_level,
      yield_tag: 'Medium',
      estimated_minutes: l.estimated_minutes,
      is_checkpoint: false,
      in_degree: 0,
      out_degree: 0,

      // Store the plans inside content_payload so the Worker can access them later
      content_payload: {
        // This preserves the 'content_plans' object (reading prompt, video queries, etc.)
        generation_plans: l.content_plans || {}
      },

      module_ref: l.module_group,
      created_at: new Date().toISOString(),
      confidence_score: confidenceScore,
      metadata: {
        original_source_ids: sources,
        architectural_reasoning: l.architectural_reasoning
      }
    };
  });

  const finalEdges = [];

  // Calculate degrees and build edges
  lessonGraph.lessons.forEach(l => {
    const childId = slugToUuid.get(l.slug_id);
    l.dependencies.forEach(parentSlug => {
      const parentId = slugToUuid.get(parentSlug);
      if (parentId) {
        finalEdges.push({
          parent_id: parentId,
          child_id: childId
        });

        // Update degrees
        const childNode = finalNodes.find(n => n.id === childId);
        const parentNode = finalNodes.find(n => n.id === parentId);
        if (childNode) childNode.in_degree = (childNode.in_degree || 0) + 1;
        if (parentNode) parentNode.out_degree = (parentNode.out_degree || 0) + 1;
      }
    });
  });

  return { finalNodes, finalEdges };
}

/**
 * Generates a Review Module based on a list of graded topics.
 * @param {Array<{topic: string, grade: number, explanation: string}>} topics - List of topics with grades and feedback.
 * @param {string} type - 'midterm' or 'final'.
 * @returns {Promise<{ finalNodes: any[], finalEdges: any[] }>}
 */
export async function generateReviewModule(topics, type, userId) {
  const systemPrompt = `You are the Lesson Architect. Your goal is to create a Review Module for a ${type} exam based on the provided graded topics.

INPUT: A list of topics with student grades (1-5 scale) and explanations of their performance.
OUTPUT: A structured JSON object containing a list of lessons.

CRITICAL RULES:
1. **Prioritize Weaknesses:** Focus heavily on topics where the grade is low (1-3). You can group strong topics (4-5) into a quick summary lesson or omit them if the list is long.
2. **Granularity:** Create lessons that take 15-30 minutes. Group related weak topics into cohesive lessons.
3. **Module Group:** ALL lessons must have "module_group" set to "${type} Review".
4. **Content:** Include readings (summary/review), videos (if helpful), and quizzes.
5. **Practice:** Include a "practice_exam" content plan for at least one lesson, or spread practice problems across lessons.
6. **IDs:** Use kebab-case slug_ids.
7. **Reasoning:** Explain why you grouped topics this way and how you addressed the specific weaknesses mentioned in the input.

Output STRICT VALID JSON format (no markdown, no comments):
{
  "lessons": [
    {
      "slug_id": "topic-review",
      "title": "Review: Topic Name",
      "module_group": "${type} Review",
      "estimated_minutes": 30,
      "bloom_level": "Analyze",
      "intrinsic_exam_value": 10,
      "architectural_reasoning": "Focused on this because the student scored 1/5 due to...",
      "dependencies": [],
      "content_plans": {
         "reading": "Review the key concepts of...",
         "video": ["topic explanation"],
         "quiz": "Create review questions...",
         "practice_exam": "Create 2 free response problems..."
      }
    }
  ]
}`;

  const userPrompt = `Student Performance Report: ${JSON.stringify(topics)}`;

  const { result } = await llmCaller({
    stage: STAGES.LESSON_ARCHITECT,
    maxTokens: 10000,
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ],
    responseFormat: { type: 'json_object' },
    requestTimeoutMs: 600000,
    userId,
  });

  let lessonGraph;
  try {
    const cleanJson = result.content
      .replace(/^```json\s*/, '')
      .replace(/^```\s*/, '')
      .replace(/\s*```$/, '')
      .replace(/\\'/g, "'");

    lessonGraph = tryParseJson(cleanJson, 'ReviewModuleArchitect');
  } catch (e) {
    throw new Error('Invalid JSON response from Lesson Architect for Review Module');
  }

  if (!lessonGraph || !Array.isArray(lessonGraph.lessons)) {
    throw new Error('Invalid response structure: missing lessons array');
  }

  // Normalization & Output
  const slugToUuid = new Map();
  lessonGraph.lessons.forEach(l => slugToUuid.set(l.slug_id, uuidv4()));

  const finalNodes = lessonGraph.lessons.map(l => {
    return {
      id: slugToUuid.get(l.slug_id),
      title: l.title,
      description: null,
      intrinsic_exam_value: l.intrinsic_exam_value,
      bloom_level: l.bloom_level,
      yield_tag: 'High', // Review modules are usually high yield
      estimated_minutes: l.estimated_minutes,
      is_checkpoint: false,
      in_degree: 0,
      out_degree: 0,
      content_payload: {
        generation_plans: l.content_plans || {}
      },
      module_ref: l.module_group,
      created_at: new Date().toISOString(),
      confidence_score: 1.0, // Generated from known topics
      metadata: {
        architectural_reasoning: l.architectural_reasoning,
        review_type: type // Tag for fetching later
      }
    };
  });

  const finalEdges = [];
  // We assume review lessons are mostly independent or linear, but if the LLM outputs dependencies, we respect them.
  lessonGraph.lessons.forEach(l => {
    const childId = slugToUuid.get(l.slug_id);
    if (l.dependencies) {
      l.dependencies.forEach(parentSlug => {
        const parentId = slugToUuid.get(parentSlug);
        if (parentId) {
          finalEdges.push({
            parent_id: parentId,
            child_id: childId
          });
          const childNode = finalNodes.find(n => n.id === childId);
          const parentNode = finalNodes.find(n => n.id === parentId);
          if (childNode) childNode.in_degree = (childNode.in_degree || 0) + 1;
          if (parentNode) parentNode.out_degree = (parentNode.out_degree || 0) + 1;
        }
      });
    }
  });

  return { finalNodes, finalEdges };
}
