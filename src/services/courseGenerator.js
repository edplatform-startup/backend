import { v4 as uuidv4 } from 'uuid';
import stringSimilarity from 'string-similarity';
import { callStageLLM as defaultLLMCaller } from './llmCall.js';

let llmCaller = defaultLLMCaller;

export function __setLLMCaller(fn) {
  llmCaller = fn;
}

export function __resetLLMCaller() {
  llmCaller = defaultLLMCaller;
}
import { STAGES } from './modelRouter.js';
import { tryParseJson } from '../utils/jsonUtils.js';

/**
 * @typedef {Object} ContentPlans
 * @property {string} [reading] - Prompt for reading generation
 * @property {string[]} [video] - Search queries for video
 * @property {string} [quiz] - Prompt for quiz generation
 * @property {string} [flashcards] - Prompt for flashcard generation
 * @property {string} [practice_exam] - Prompt for practice exam generation
 */

/**
 * @typedef {Object} LessonNode
 * @property {string} slug_id
 * @property {string} title
 * @property {string} module_group
 * @property {number} estimated_minutes
 * @property {"Remember" | "Understand" | "Apply" | "Analyze" | "Evaluate"} bloom_level
 * @property {number} intrinsic_exam_value
 * @property {string} architectural_reasoning
 * @property {ContentPlans} content_plans
 * @property {string[]} dependencies
 * @property {string[]} [original_source_ids]
 */

/**
 * @typedef {Object} LessonGraph
 * @property {LessonNode[]} lessons
 */

/**
 * Generates a DAG of atomic lessons from a rough course draft.
 * @param {Object} grokDraftJson - The rough draft JSON from Grok.
 * @param {Object} userConfidenceMap - Map of slug_id -> confidence_score (0-1).
 * @returns {Promise<{ finalNodes: any[], finalEdges: any[] }>}
 */
export async function generateLessonGraph(grokDraftJson, userConfidenceMap = {}) {
  console.log('[LessonArchitect] Starting generation...');

  // Step 1: The Architect Call
  const systemPrompt = `You are the Lesson Architect. Your goal is to transform a rough course outline into a high-quality Directed Acyclic Graph (DAG) of Atomic Lessons.

INPUT: A rough course draft (JSON) generated by a junior process.
OUTPUT: A structured JSON object containing a list of lessons with dependencies.

CRITICAL RULES:
1. **Granularity:** "Atomic" means a lesson that takes 15-45 minutes to complete. Split broad topics. Merge tiny fragments (unless foundational).
2. **Lineage:** You MUST track the 'original_source_ids' from the input. If you merge topics, list ALL their IDs. This preserves user data.
3. **No Cycles:** The graph must be strictly Acyclic.
4. **Content Type Diversity:** You may include MULTIPLE instances of each content type per lesson if appropriate for learning:
   - A lesson can have multiple readings (e.g., theory + examples + edge cases)
   - A lesson can have multiple videos (e.g., intro + deep dive + worked examples)
   - A lesson can have multiple quizzes (e.g., conceptual check + application problems)
  - A lesson can include practice exams or longer free-response drills to mirror midterm/final formats
   - ALL content should flow in a logical learning order for maximum comprehension
5. **Lesson-End Quizzes:** IMPORTANT: Always include a quiz as the LAST content type in each lesson. This quiz should assess understanding of the entire module's content.
6. **Specific Generation Plans:** For each content type you include, provide detailed, specific prompts:
   - **reading:** Highly detailed prompt for a writer (e.g., "Use a gear analogy," "Focus on formal proofs"). Focus on intuitive understanding and exact topics.
   - **video:** 2-3 general, high-level YouTube search queries for broad concepts (e.g., "Introduction to Photosynthesis" rather than "Calvin Cycle Step 3"). IMPORTANT: Only include video plans if the concept is exceptionally difficult, the user is weak on it, or a visual demonstration is absolutely necessary. Otherwise, omit.
   - **quiz:** Detailed prompt for an examiner. Explicitly request varying difficulty levels (Easy, Medium, Hard) and ensure at least one "Challenge Question" that would test even a strong student.
   - **flashcards:** Prompt focusing on what to memorize (definitions vs. procedural steps).
  - **practice_exam:** Prompt describing the desired number of free-response problems, rubric expectations, and authentic exam traps to include.
7. **IDs:** Use "Semantic Slugs" (kebab-case) for IDs.
8. **Reasoning:** The 'architectural_reasoning' field must explain your grouping logic, why you assigned the specific exam value (1-10), and why you chose the specific content mix.
9. **Naming:** NEVER number modules or lessons in the title (e.g., 'Introduction', not '1. Introduction').

Output STRICT VALID JSON format (no markdown, no comments):
{
  "lessons": [
    {
      "slug_id": "chain-rule-application",
      "title": "Mastering the Chain Rule",
      "module_group": "Week 1: Limits",
      "estimated_minutes": 30,
      "bloom_level": "Apply",
      "intrinsic_exam_value": 8,
      "architectural_reasoning": "Merged st1_1 and st1_2 to create a cohesive 30-min lesson. Rated 8/10 because the syllabus highlights this for the midterm.",
      "dependencies": ["limits-intro"],
      "original_source_ids": ["st1_1", "st1_2"],
      
      "content_plans": {
         "reading": "Explain the chain rule using a 'peeling the onion' analogy. Focus on identifying inner vs outer functions.",
         "video": ["chain rule calculus intuition", "chain rule visualization 3blue1brown"],
         "quiz": "Generate 3 multiple-choice questions. One must involve a trigonometric function inside a polynomial.",
         "flashcards": "Focus on the formula f'(g(x))g'(x) and recognizing composite functions."
      }
    }
  ]
}`;

  const userPrompt = `Rough Draft: ${JSON.stringify(grokDraftJson)}`;

  console.log('[LessonArchitect] Calling Gemini 3 Pro...');
  const { result } = await llmCaller({
    stage: STAGES.LESSON_ARCHITECT,
    maxTokens: 20000,
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ],
    responseFormat: { type: 'json_object' },
    requestTimeoutMs: 1800000, // 30 minutes for long-running course generation
    allowWeb: true,
    maxToolIterations: 16,
  });

  let lessonGraph;
  try {
    const cleanJson = result.content
      .replace(/^```json\s*/, '')
      .replace(/^```\s*/, '')
      .replace(/\s*```$/, '')
      .replace(/\\'/g, "'");

    lessonGraph = tryParseJson(cleanJson, 'LessonArchitect');
  } catch (e) {
    console.error('[LessonArchitect] Failed to parse JSON from Gemini:', e);
    console.error('[LessonArchitect] Raw Content Length:', result?.content ? result.content.length : 'N/A');
    console.error('[LessonArchitect] FULL RESULT OBJECT:', JSON.stringify(result, null, 2));
    throw new Error('Invalid JSON response from Lesson Architect');
  }

  if (!lessonGraph || !Array.isArray(lessonGraph.lessons)) {
    throw new Error('Invalid response structure: missing lessons array');
  }

  console.log(`[LessonArchitect] Received ${lessonGraph.lessons.length} lessons.`);

  // Step 2: Self-Healing Validation Logic
  const validSlugs = new Set(lessonGraph.lessons.map((l) => l.slug_id));
  const brokenDependenciesMap = new Map(); // lesson_slug -> [bad_deps]

  // Stage 1: Fuzzy Repair & Identification
  for (const lesson of lessonGraph.lessons) {
    const newDependencies = [];
    const badDepsForLesson = [];

    for (const dep of lesson.dependencies || []) {
      if (validSlugs.has(dep)) {
        newDependencies.push(dep);
      } else {
        console.warn(`[LessonArchitect] Invalid dependency '${dep}' in lesson '${lesson.slug_id}'. Attempting fuzzy repair...`);
        const matches = stringSimilarity.findBestMatch(dep, Array.from(validSlugs));
        if (matches.bestMatch.rating > 0.9) {
          console.log(`[LessonArchitect] Fuzzy repaired '${dep}' -> '${matches.bestMatch.target}'`);
          newDependencies.push(matches.bestMatch.target);
        } else {
          // Keep it for Stage 2, but track it as broken
          newDependencies.push(dep);
          badDepsForLesson.push(dep);
        }
      }
    }
    lesson.dependencies = newDependencies;
    if (badDepsForLesson.length > 0) {
      brokenDependenciesMap.set(lesson.slug_id, badDepsForLesson);
    }
  }

  // Stage 2: Targeted Regeneration
  if (brokenDependenciesMap.size > 0) {
    console.log(`[LessonArchitect] Found ${brokenDependenciesMap.size} lessons with broken dependencies. Attempting LLM repair...`);

    const allBadSlugs = new Set();
    for (const deps of brokenDependenciesMap.values()) {
      deps.forEach(d => allBadSlugs.add(d));
    }

    const repairPrompt = `You generated these nodes: ${JSON.stringify(Array.from(validSlugs))}.
You referenced these non-existent dependencies: ${JSON.stringify(Array.from(allBadSlugs))}.
Return a JSON map correcting the Bad Slugs to existing ones, or map to null to remove.
Example: { "bad-slug": "good-slug", "another-bad": null }`;

    try {
      const { result: repairResult } = await llmCaller({
        stage: STAGES.LESSON_ARCHITECT, // Re-use same stage/model
        maxTokens: 8000,
        messages: [{ role: 'user', content: repairPrompt }],
        responseFormat: { type: 'json_object' },
        requestTimeoutMs: 1800000, // 30 minutes for repair call as well
      });

      const corrections = tryParseJson(repairResult.content, 'LessonArchitect Repair');
      console.log('[LessonArchitect] Received corrections:', corrections);

      // Apply corrections
      for (const [slug, badDeps] of brokenDependenciesMap.entries()) {
        const lesson = lessonGraph.lessons.find(l => l.slug_id === slug);
        if (!lesson) continue;

        const finalDeps = [];
        for (const dep of lesson.dependencies) {
          if (badDeps.includes(dep)) {
            const correction = corrections[dep];
            if (correction && validSlugs.has(correction)) {
              console.log(`[LessonArchitect] LLM repaired '${dep}' -> '${correction}'`);
              finalDeps.push(correction);
            } else {
              // Stage 3: Orphan Fallback
              console.warn(`[LessonArchitect] Dropping invalid dependency '${dep}' for lesson '${slug}' to preserve content.`);
            }
          } else {
            finalDeps.push(dep);
          }
        }
        lesson.dependencies = [...new Set(finalDeps)]; // Dedupe
      }

    } catch (e) {
      console.error('[LessonArchitect] LLM repair failed:', e);
      // Fallback to dropping all bad deps (Stage 3) implicitly since we didn't add them back
    }
  }

  // Step 3: Normalization & Output
  const slugToUuid = new Map();
  lessonGraph.lessons.forEach(l => slugToUuid.set(l.slug_id, uuidv4()));

  const finalNodes = lessonGraph.lessons.map(l => {
    // Calculate Confidence Score
    let confidenceSum = 0;
    let sourceCount = 0;
    const sources = l.original_source_ids || [];

    if (sources.length > 0) {
      sources.forEach(sid => {
        if (typeof userConfidenceMap[sid] === 'number') {
          confidenceSum += userConfidenceMap[sid];
          sourceCount++;
        }
      });
    }

    // Default to 0.1 if no sources or no matching scores
    const confidenceScore = sourceCount > 0 ? Number((confidenceSum / sourceCount).toFixed(2)) : 0.1;

    return {
      id: slugToUuid.get(l.slug_id),
      title: l.title,
      description: null,
      intrinsic_exam_value: l.intrinsic_exam_value,
      bloom_level: l.bloom_level,
      yield_tag: 'Medium',
      estimated_minutes: l.estimated_minutes,
      is_checkpoint: false,
      in_degree: 0,
      out_degree: 0,

      // Store the plans inside content_payload so the Worker can access them later
      content_payload: {
        // This preserves the 'content_plans' object (reading prompt, video queries, etc.)
        generation_plans: l.content_plans || {}
      },

      module_ref: l.module_group,
      created_at: new Date().toISOString(),
      confidence_score: confidenceScore,
      metadata: {
        original_source_ids: sources,
        architectural_reasoning: l.architectural_reasoning
      }
    };
  });

  const finalEdges = [];

  // Calculate degrees and build edges
  lessonGraph.lessons.forEach(l => {
    const childId = slugToUuid.get(l.slug_id);
    l.dependencies.forEach(parentSlug => {
      const parentId = slugToUuid.get(parentSlug);
      if (parentId) {
        finalEdges.push({
          parent_id: parentId,
          child_id: childId
        });

        // Update degrees
        const childNode = finalNodes.find(n => n.id === childId);
        const parentNode = finalNodes.find(n => n.id === parentId);
        if (childNode) childNode.in_degree = (childNode.in_degree || 0) + 1;
        if (parentNode) parentNode.out_degree = (parentNode.out_degree || 0) + 1;
      }
    });
  });

  console.log(`[LessonArchitect] Finished. Nodes: ${finalNodes.length}, Edges: ${finalEdges.length}`);
  
  // Insert Practice Exams (Mid-Term and Final)
  const { nodes: nodesWithExams, edges: edgesWithExams } = insertPracticeExams(finalNodes, finalEdges);
  
  return { finalNodes: nodesWithExams, finalEdges: edgesWithExams };
}

/**
 * Inserts Mid-Term and Final Practice Exams into the DAG.
 * - Mid-Term: Inserted after the first 50% of topologically sorted nodes.
 * - Final: Inserted after all nodes.
 */
function insertPracticeExams(nodes, edges) {
  if (nodes.length < 2) return { nodes, edges };

  const sortedIds = topologicalSort(nodes, edges);
  if (!sortedIds) {
    console.warn('[insertPracticeExams] Cycle detected or sort failed. Skipping exam insertion.');
    return { nodes, edges };
  }

  const midIndex = Math.floor(sortedIds.length / 2);
  const midTermPrecedingIds = sortedIds.slice(0, midIndex);
  const finalPrecedingIds = sortedIds; // All nodes precede the final

  const newNodes = [...nodes];
  const newEdges = [...edges];

  // --- Mid-Term Exam ---
  if (midIndex > 0) {
    const midTermId = uuidv4();
    const precedingNodes = midTermPrecedingIds.map(id => nodes.find(n => n.id === id)).filter(Boolean);
    
    const midTermNode = {
      id: midTermId,
      title: 'Mid-Term Practice Exam',
      description: 'A comprehensive check of the first half of the course.',
      intrinsic_exam_value: 10,
      bloom_level: 'Evaluate',
      yield_tag: 'High',
      estimated_minutes: 45,
      is_checkpoint: true,
      in_degree: 0, // Will be updated
      out_degree: 0,
      content_payload: {
        generation_plans: {
          practice_exam: `Create a mid-term exam covering these lessons: ${precedingNodes.map(n => n.title).join(', ')}. Focus on integrating concepts.`
        }
      },
      module_ref: 'Mid-Term Assessment',
      created_at: new Date().toISOString(),
      confidence_score: 1.0,
      metadata: {
        preceding_lessons: precedingNodes.map(n => ({ id: n.id, title: n.title }))
      }
    };

    newNodes.push(midTermNode);

    // Add edge from the last node of the first half to the Mid-Term
    // To enforce "halfway", we can make it depend on the node at midIndex-1
    const lastPrecedingId = sortedIds[midIndex - 1];
    newEdges.push({ parent_id: lastPrecedingId, child_id: midTermId });

    // And make the next node (start of second half) depend on the Mid-Term
    if (midIndex < sortedIds.length) {
      const firstNextId = sortedIds[midIndex];
      newEdges.push({ parent_id: midTermId, child_id: firstNextId });
    }
  }

  // --- Final Exam ---
  const finalExamId = uuidv4();
  const allPrecedingNodes = finalPrecedingIds.map(id => nodes.find(n => n.id === id)).filter(Boolean);

  const finalExamNode = {
    id: finalExamId,
    title: 'Final Practice Exam',
    description: 'The final assessment covering the entire course.',
    intrinsic_exam_value: 10,
    bloom_level: 'Evaluate',
    yield_tag: 'High',
    estimated_minutes: 60,
    is_checkpoint: true,
    in_degree: 0,
    out_degree: 0,
    content_payload: {
      generation_plans: {
        practice_exam: `Create a final exam covering the entire course. Prioritize high-yield topics from: ${allPrecedingNodes.map(n => n.title).join(', ')}.`
      }
    },
    module_ref: 'Final Assessment',
    created_at: new Date().toISOString(),
    confidence_score: 1.0,
    metadata: {
      preceding_lessons: allPrecedingNodes.map(n => ({ id: n.id, title: n.title }))
    }
  };

  newNodes.push(finalExamNode);

  // Add edge from the very last node to the Final Exam
  // (Or strictly, it should depend on ALL leaf nodes of the original graph? 
  //  Simpler: depend on the last node in topological sort to ensure it comes last)
  const lastNodeId = sortedIds[sortedIds.length - 1];
  newEdges.push({ parent_id: lastNodeId, child_id: finalExamId });

  // Re-calculate degrees for new graph
  // Reset degrees
  newNodes.forEach(n => { n.in_degree = 0; n.out_degree = 0; });
  newEdges.forEach(e => {
    const p = newNodes.find(n => n.id === e.parent_id);
    const c = newNodes.find(n => n.id === e.child_id);
    if (p) p.out_degree++;
    if (c) c.in_degree++;
  });

  return { nodes: newNodes, edges: newEdges };
}

/**
 * Kahn's Algorithm for Topological Sort
 * Returns array of node IDs in sorted order, or null if cycle detected.
 */
function topologicalSort(nodes, edges) {
  const inDegree = new Map();
  const adj = new Map();

  nodes.forEach(n => {
    inDegree.set(n.id, 0);
    adj.set(n.id, []);
  });

  edges.forEach(e => {
    inDegree.set(e.child_id, (inDegree.get(e.child_id) || 0) + 1);
    const list = adj.get(e.parent_id) || [];
    list.push(e.child_id);
    adj.set(e.parent_id, list);
  });

  const queue = [];
  inDegree.forEach((deg, id) => {
    if (deg === 0) queue.push(id);
  });

  const result = [];
  while (queue.length > 0) {
    const u = queue.shift();
    result.push(u);

    const neighbors = adj.get(u) || [];
    for (const v of neighbors) {
      inDegree.set(v, inDegree.get(v) - 1);
      if (inDegree.get(v) === 0) {
        queue.push(v);
      }
    }
  }

  if (result.length !== nodes.length) {
    return null; // Cycle detected
  }

  return result;
}