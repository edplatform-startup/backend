import { v4 as uuidv4 } from 'uuid';
import stringSimilarity from 'string-similarity';
import { callStageLLM } from './llmCall.js';
import { STAGES } from './modelRouter.js';

let llmCaller = callStageLLM;

export function __setLLMCaller(fn) {
  llmCaller = fn;
}

/**
 * @typedef {Object} ContentPlans
 * @property {string} [reading] - Prompt for reading generation
 * @property {string[]} [video] - Search queries for video
 * @property {string} [quiz] - Prompt for quiz generation
 * @property {string} [flashcards] - Prompt for flashcard generation
 * @property {string} [practice_exam] - Prompt for practice exam generation
 */

/**
 * @typedef {Object} LessonNode
 * @property {string} slug_id
 * @property {string} title
 * @property {string} module_group
 * @property {number} estimated_minutes
 * @property {"Remember" | "Understand" | "Apply" | "Analyze" | "Evaluate"} bloom_level
 * @property {number} intrinsic_exam_value
 * @property {string} architectural_reasoning
 * @property {ContentPlans} content_plans  <-- UPDATED: New structure
 * @property {string[]} dependencies
 * @property {string[]} [original_source_ids]
 */

/**
 * @typedef {Object} LessonGraph
 * @property {LessonNode[]} lessons
 */

/**
 * Generates a DAG of atomic lessons from a rough course draft.
 * @param {Object} grokDraftJson - The rough draft JSON from Grok.
 * @param {Object} userConfidenceMap - Map of slug_id -> confidence_score (0-1).
 * @returns {Promise<{ finalNodes: any[], finalEdges: any[] }>}
 */
export async function generateLessonGraph(grokDraftJson, userConfidenceMap = {}) {
  console.log('[LessonArchitect] Starting generation...');

  // Step 1: The Architect Call
  const systemPrompt = `You are the Lesson Architect. Your goal is to transform a rough course outline into a high-quality Directed Acyclic Graph (DAG) of Atomic Lessons.

INPUT: A rough course draft (JSON) generated by a junior process.
OUTPUT: A structured JSON object containing a list of lessons with dependencies.

CRITICAL RULES:
1. **Granularity:** "Atomic" means a lesson that takes 15-45 minutes to complete. Split broad topics. Merge tiny fragments (unless foundational).
2. **Lineage:** You MUST track the 'original_source_ids' from the input. If you merge topics, list ALL their IDs. This preserves user data.
3. **No Cycles:** The graph must be strictly Acyclic.
4. **Content Type Diversity:** You may include MULTIPLE instances of each content type per lesson if appropriate for learning:
   - A lesson can have multiple readings (e.g., theory + examples + edge cases)
   - A lesson can have multiple videos (e.g., intro + deep dive + worked examples)
   - A lesson can have multiple quizzes (e.g., conceptual check + application problems)
  - A lesson can include practice exams or longer free-response drills to mirror midterm/final formats
   - ALL content should flow in a logical learning order for maximum comprehension
5. **Lesson-End Quizzes:** IMPORTANT: Always include a quiz as the LAST content type in each lesson. This quiz should assess understanding of the entire module's content.
6. **Specific Generation Plans:** For each content type you include, provide detailed, specific prompts:
   - **reading:** Highly detailed prompt for a writer (e.g., "Use a gear analogy," "Focus on formal proofs"). Focus on intuitive understanding and exact topics.
   - **video:** 2-3 specific YouTube search queries likely to yield high-quality tutorials.
   - **quiz:** Detailed prompt for an examiner (e.g., "Create 3 questions that test the 'add constant' trap," "Include one conceptual and two application questions").
   - **flashcards:** Prompt focusing on what to memorize (definitions vs. procedural steps).
  - **practice_exam:** Prompt describing the desired number of free-response problems, rubric expectations, and authentic exam traps to include.
7. **IDs:** Use "Semantic Slugs" (kebab-case) for IDs.
8. **Reasoning:** The 'architectural_reasoning' field must explain your grouping logic, why you assigned the specific exam value (1-10), and why you chose the specific content mix.
9. **Naming:** NEVER number modules or lessons in the title (e.g., 'Introduction', not '1. Introduction').

Output STRICT VALID JSON format (no markdown, no comments):
{
  "lessons": [
    {
      "slug_id": "chain-rule-application",
      "title": "Mastering the Chain Rule",
      "module_group": "Week 1: Limits",
      "estimated_minutes": 30,
      "bloom_level": "Apply",
      "intrinsic_exam_value": 8,
      "architectural_reasoning": "Merged st1_1 and st1_2 to create a cohesive 30-min lesson. Rated 8/10 because the syllabus highlights this for the midterm.",
      "dependencies": ["limits-intro"],
      "original_source_ids": ["st1_1", "st1_2"],
      
      "content_plans": {
         "reading": "Explain the chain rule using a 'peeling the onion' analogy. Focus on identifying inner vs outer functions.",
         "video": ["chain rule calculus intuition", "chain rule visualization 3blue1brown"],
         "quiz": "Generate 3 multiple-choice questions. One must involve a trigonometric function inside a polynomial.",
         "flashcards": "Focus on the formula f'(g(x))g'(x) and recognizing composite functions."
      }
    }
  ]
}`;

  const userPrompt = `Rough Draft: ${JSON.stringify(grokDraftJson)}`;

  console.log('[LessonArchitect] Calling Gemini 3 Pro...');
  const { result } = await llmCaller({
    stage: STAGES.LESSON_ARCHITECT,
    maxTokens: 20000,
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ],
    responseFormat: { type: 'json_object' },
    requestTimeoutMs: 1800000, // 30 minutes for long-running course generation
    allowWeb: true,
    maxToolIterations: 16,
  });

  let lessonGraph;
  try {
    const cleanJson = result.content
      .replace(/^```json\s*/, '')
      .replace(/^```\s*/, '')
      .replace(/\s*```$/, '')
      .replace(/\\'/g, "'");

    lessonGraph = JSON.parse(cleanJson);
  } catch (e) {
    console.error('[LessonArchitect] Failed to parse JSON from Gemini:', e);
    console.error('[LessonArchitect] Raw Content Length:', result?.content ? result.content.length : 'N/A');
    console.error('[LessonArchitect] FULL RESULT OBJECT:', JSON.stringify(result, null, 2));
    throw new Error('Invalid JSON response from Lesson Architect');
  }

  if (!lessonGraph || !Array.isArray(lessonGraph.lessons)) {
    throw new Error('Invalid response structure: missing lessons array');
  }

  console.log(`[LessonArchitect] Received ${lessonGraph.lessons.length} lessons.`);

  // Step 2: Self-Healing Validation Logic
  const validSlugs = new Set(lessonGraph.lessons.map((l) => l.slug_id));
  const brokenDependenciesMap = new Map(); // lesson_slug -> [bad_deps]

  // Stage 1: Fuzzy Repair & Identification
  for (const lesson of lessonGraph.lessons) {
    const newDependencies = [];
    const badDepsForLesson = [];

    for (const dep of lesson.dependencies || []) {
      if (validSlugs.has(dep)) {
        newDependencies.push(dep);
      } else {
        console.warn(`[LessonArchitect] Invalid dependency '${dep}' in lesson '${lesson.slug_id}'. Attempting fuzzy repair...`);
        const matches = stringSimilarity.findBestMatch(dep, Array.from(validSlugs));
        if (matches.bestMatch.rating > 0.9) {
          console.log(`[LessonArchitect] Fuzzy repaired '${dep}' -> '${matches.bestMatch.target}'`);
          newDependencies.push(matches.bestMatch.target);
        } else {
          // Keep it for Stage 2, but track it as broken
          newDependencies.push(dep);
          badDepsForLesson.push(dep);
        }
      }
    }
    lesson.dependencies = newDependencies;
    if (badDepsForLesson.length > 0) {
      brokenDependenciesMap.set(lesson.slug_id, badDepsForLesson);
    }
  }

  // Stage 2: Targeted Regeneration
  if (brokenDependenciesMap.size > 0) {
    console.log(`[LessonArchitect] Found ${brokenDependenciesMap.size} lessons with broken dependencies. Attempting LLM repair...`);

    const allBadSlugs = new Set();
    for (const deps of brokenDependenciesMap.values()) {
      deps.forEach(d => allBadSlugs.add(d));
    }

    const repairPrompt = `You generated these nodes: ${JSON.stringify(Array.from(validSlugs))}.
You referenced these non-existent dependencies: ${JSON.stringify(Array.from(allBadSlugs))}.
Return a JSON map correcting the Bad Slugs to existing ones, or map to null to remove.
Example: { "bad-slug": "good-slug", "another-bad": null }`;

    try {
      const { result: repairResult } = await llmCaller({
        stage: STAGES.LESSON_ARCHITECT, // Re-use same stage/model
        maxTokens: 8000,
        messages: [{ role: 'user', content: repairPrompt }],
        responseFormat: { type: 'json_object' },
        requestTimeoutMs: 1800000, // 30 minutes for repair call as well
      });

      const corrections = JSON.parse(repairResult.content);
      console.log('[LessonArchitect] Received corrections:', corrections);

      // Apply corrections
      for (const [slug, badDeps] of brokenDependenciesMap.entries()) {
        const lesson = lessonGraph.lessons.find(l => l.slug_id === slug);
        if (!lesson) continue;

        const finalDeps = [];
        for (const dep of lesson.dependencies) {
          if (badDeps.includes(dep)) {
            const correction = corrections[dep];
            if (correction && validSlugs.has(correction)) {
              console.log(`[LessonArchitect] LLM repaired '${dep}' -> '${correction}'`);
              finalDeps.push(correction);
            } else {
              // Stage 3: Orphan Fallback
              console.warn(`[LessonArchitect] Dropping invalid dependency '${dep}' for lesson '${slug}' to preserve content.`);
            }
          } else {
            finalDeps.push(dep);
          }
        }
        lesson.dependencies = [...new Set(finalDeps)]; // Dedupe
      }

    } catch (e) {
      console.error('[LessonArchitect] LLM repair failed:', e);
      // Fallback to dropping all bad deps (Stage 3) implicitly since we didn't add them back
    }
  }

  // Step 3: Normalization & Output
  const slugToUuid = new Map();
  lessonGraph.lessons.forEach(l => slugToUuid.set(l.slug_id, uuidv4()));

  const finalNodes = lessonGraph.lessons.map(l => {
    // Calculate Confidence Score
    let confidenceSum = 0;
    let sourceCount = 0;
    const sources = l.original_source_ids || [];

    if (sources.length > 0) {
      sources.forEach(sid => {
        if (typeof userConfidenceMap[sid] === 'number') {
          confidenceSum += userConfidenceMap[sid];
          sourceCount++;
        }
      });
    }

    // Default to 0.1 if no sources or no matching scores
    const confidenceScore = sourceCount > 0 ? Number((confidenceSum / sourceCount).toFixed(2)) : 0.1;

    return {
      id: slugToUuid.get(l.slug_id),
      title: l.title,
      description: null,
      intrinsic_exam_value: l.intrinsic_exam_value,
      bloom_level: l.bloom_level,
      yield_tag: 'Medium',
      estimated_minutes: l.estimated_minutes,
      is_checkpoint: false,
      in_degree: 0,
      out_degree: 0,

      // --- FIX START ---
      // Store the plans inside content_payload so the Worker can access them later
      content_payload: {
        // This preserves the 'content_plans' object (reading prompt, video queries, etc.)
        generation_plans: l.content_plans || {}
      },
      // We map the 'reading' prompt to the old column just in case, or stringify the whole object
      generation_prompt: l.content_plans ? JSON.stringify(l.content_plans) : null,
      // --- FIX END ---

      module_ref: l.module_group,
      created_at: new Date().toISOString(),
      confidence_score: confidenceScore,
      metadata: {
        original_source_ids: sources,
        architectural_reasoning: l.architectural_reasoning
      }
    };
  });

  const finalEdges = [];

  // Calculate degrees and build edges
  lessonGraph.lessons.forEach(l => {
    const childId = slugToUuid.get(l.slug_id);
    l.dependencies.forEach(parentSlug => {
      const parentId = slugToUuid.get(parentSlug);
      if (parentId) {
        finalEdges.push({
          parent_id: parentId,
          child_id: childId
        });

        // Update degrees
        const childNode = finalNodes.find(n => n.id === childId);
        const parentNode = finalNodes.find(n => n.id === parentId);
        if (childNode) childNode.in_degree = (childNode.in_degree || 0) + 1;
        if (parentNode) parentNode.out_degree = (parentNode.out_degree || 0) + 1;
      }
    });
  });

  console.log(`[LessonArchitect] Finished. Nodes: ${finalNodes.length}, Edges: ${finalEdges.length}`);
  return { finalNodes, finalEdges };
}